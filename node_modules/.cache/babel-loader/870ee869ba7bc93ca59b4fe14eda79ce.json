{"ast":null,"code":"import { HexUtils } from 'react-hexgrid';\nexport const layout = {\n  spacing: 1,\n  orientation: {\n    f0: Math.sqrt(3.0),\n    f1: Math.sqrt(3.0) / 2.0,\n    f2: 0.0,\n    f3: 3.0 / 2.0,\n    b0: Math.sqrt(3.0) / 3.0,\n    b1: -1.0 / 3.0,\n    b2: 0.0,\n    b3: 2.0 / 3.0,\n    startAngle: 0.5\n  },\n  size: {\n    y: 3,\n    x: 3\n  },\n  origin: {\n    x: 0,\n    y: 0\n  }\n};\n/* \n    Function : generateHexes\n\n    Syntax  : hexas=generateHexes()\n    \n    Outputs : hexas : object containing all data to create the hexagones (position)\n                        and the data for the game's interaction ( activity,subBasin...)\n\n    Description : return an object containing all the data needed to generate the map in class Bassin\n        \n    Author : Hugo KELHETTER\n*/\n\nexport function generateHexes(data) {\n  let hexas = {};\n  let lstTile = {};\n  let hex;\n\n  for (let i = 0; i < data.length; i++) {\n    hex = HexUtils.pixelToHex({\n      x: data[i].xOutlet,\n      y: data[i].yOutlet\n    }, layout); //map ardiere\n    //hex = HexUtils.pixelToHex({ x: (data[i].x0 + 164.6719013516826) * 4, y: (328 + data[i].y0) * -4 }, layout)\n    // merge hex and data[i] into hexas[i]\n\n    hexas[i] = Object.assign(hex, data[i]);\n    hexas[i].modified = false;\n\n    if (hexas[i].player != null) {\n      lstTile[i] = {\n        player: hexas[i].player,\n        id: hexas[i].Id,\n        cellPlayer: hexas[i].cellPlayer\n      };\n    } //renameProperty(hexas[i], \"mainCLC1\", \"activity\")\n\n  }\n\n  return [hexas, lstTile];\n}\n/* this function doesn't work */\n\n/* export function generateMap(data) {\n    let hexas = {};\n    let hex;\n    let hex2;\n    let rivers = [];\n    let path;\n    for (let i = 0; i < data.length; i++) {\n\n        hex = HexUtils.pixelToHex({ x: (data[i].xOutlet), y: (data[i].yOutlet) }, layout)\n        //map ardiere\n        //hex = HexUtils.pixelToHex({ x: (data[i].x0 + 164.6719013516826) * 4, y: (328 + data[i].y0) * -4 }, layout)\n        // merge hex and data[i] into hexas[i]\n        if (!hexas[i]) {\n            hexas[i] = Object.assign(hex, data[i])\n            hexas[i].modified = false\n        }\n        let j = hexas[hexas[i].downTile + 2]\n        if (!hexas[j]) {\n            hexas[j] = Object.assign(hex, data[j])\n            hexas[j].modified = false\n\n        }\n        path = {\n            start: hexas[i],\n            end: hexas[j],\n            outletFlowAcc: hexas[i].outletFlowAcc\n        }\n        rivers.push(path);\n        //renameProperty(hexas[i], \"mainCLC1\", \"activity\")\n    }\n    return [hexas, rivers]\n} */\n\n/* \n    Function : generateRivers \n\n    Syntax  : rivers=generateRivers()\n\n    Outputs : array of object containing the start and end of each rivers\n\n    Description : cycle through the hexagones to create and array of object path\n                    containing the hexagon where the river starts and and where it ends\n                    by reading the downStreamCell property\n    \n    Author : Hugo KELHETTER\n*/\n\nexport function generateRivers(moreHexas) {\n  let rivers = [];\n  let path;\n\n  for (let i = 0; i < Object.keys(moreHexas).length; i++) {\n    path = {\n      start: moreHexas[i],\n      end: moreHexas[moreHexas[i].downTile - 1],\n      outletFlowAcc: moreHexas[i].outletFlowAcc\n    };\n    rivers.push(path);\n  }\n\n  return rivers;\n}\n/* \n    Function : setPlayerClass\n\n    Syntax\n        playerClass=setPlayerClass(PlayerId)\n    \n    Input\n        PlayerId    :player's id\n\n    Outputs\n        playerClass :player's id on subBasin\n\n    Description\n        Compute player's id on their subBasin based on their global id\n\n    Author : Hugo KELHETTER\n*/\n\nexport function setPlayerClass(player) {\n  if (player === 0 || player > 9) return \"\"; //attributé à aucun joueur\n\n  switch (player % 3) {\n    case 0:\n      return \"troisieme\";\n    //attribué aux joueurs 3, 6 ou 9\n\n    case 1:\n      return \"premier\";\n    //attribué aux joueurs 1, 4 ou en 7\n\n    case 2:\n      return \"deuxieme\";\n    //attribué aux joueurs 2, 5 ou 8\n\n    default:\n      return \"\";\n  }\n}\n/* \n    Function : activityToString\n\n    Syntax\n        tileActivity=activityToString(activity)\n    \n    Input\n        activity    :tile's activity\n\n    Outputs\n        tileactivity:string corresponding to the activity\n\n    Description\n        returns a string based on the input\n        this is meant to set className to components and apply css style\n    \n    Author : Hugo KELHETTER\n*/\n\nexport function activityToString(activity) {\n  switch (activity) {\n    case 1:\n      return \"ville\";\n\n    case 2:\n      return \"agriculture\";\n\n    case 3:\n      return \"foret\";\n\n    case 5:\n      return \"water\";\n\n    default:\n      return \"notInBassin\";\n  }\n}\n/* \n    Function : getSubBassin\n\n    Syntax\n        subBassin=getSubBassin(id)\n    \n    Input\n        id    :player's id\n\n    Outputs\n        playerClass :player's subBasin\n\n    Description\n        Calculate player's subBassin based on their id\n\n    Author : Hugo KELHETTER\n*/\n\nexport function getSubBassin(id) {\n  if (id < 4) return 1;\n  if (id < 7) return 2;\n  return 3;\n}\n/* \n    Function : setMapSize\n\n    Syntax : setMapSize()\n        \n    Description : return a size considering if the scrren if in portrait or landscape \n        \n*/\n\nexport function setMapSize() {\n  return window.matchMedia('(orientation:landscape)').matches ? '50%' : '100%';\n}\n/* \n    Function : setBaseCLasses \n    \n    Syntax  : classes=setBaseClasses(hex)\n    \n    Input   : hex : object : contains the data of an hexagon\n    \n    Output : classes : string : a set of css classes to add to the hexagon\n\n    Description : return a string of classes to add to the hexagon\n        \n    Author : Hugo KELHETTER\n*/\n\nexport function setBaseClasses(hex) {\n  let classname = activityToString(hex.mainCLC1);\n  if (hex.eco == 1) classname += \" eco\";\n  return classname;\n}","map":{"version":3,"sources":["/home/elouati/Bureau/expeau/src/Game/map/MapUtil.js"],"names":["HexUtils","layout","spacing","orientation","f0","Math","sqrt","f1","f2","f3","b0","b1","b2","b3","startAngle","size","y","x","origin","generateHexes","data","hexas","lstTile","hex","i","length","pixelToHex","xOutlet","yOutlet","Object","assign","modified","player","id","Id","cellPlayer","generateRivers","moreHexas","rivers","path","keys","start","end","downTile","outletFlowAcc","push","setPlayerClass","activityToString","activity","getSubBassin","setMapSize","window","matchMedia","matches","setBaseClasses","classname","mainCLC1","eco"],"mappings":"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","sourcesContent":["import { HexUtils } from 'react-hexgrid'\nexport const layout = {\n    spacing: 1,\n    orientation: {\n        f0: Math.sqrt(3.0), f1: Math.sqrt(3.0) / 2.0, f2: 0.0, f3: 3.0 / 2.0, b0: Math.sqrt(3.0) / 3.0, b1: -1.0 / 3.0, b2: 0.0, b3: 2.0 / 3.0, startAngle: 0.5\n    },\n    size: {\n        y: 3,\n        x: 3,\n    },\n    origin: {\n        x: 0,\n        y: 0,\n    },\n}\n/* \n    Function : generateHexes\n\n    Syntax  : hexas=generateHexes()\n    \n    Outputs : hexas : object containing all data to create the hexagones (position)\n                        and the data for the game's interaction ( activity,subBasin...)\n\n    Description : return an object containing all the data needed to generate the map in class Bassin\n        \n    Author : Hugo KELHETTER\n*/\nexport function generateHexes(data) {\n    let hexas = {};\n    let lstTile = {}\n    let hex;\n    for (let i = 0; i < data.length; i++) {\n\n        hex = HexUtils.pixelToHex({ x: (data[i].xOutlet), y: (data[i].yOutlet) }, layout)\n        //map ardiere\n        //hex = HexUtils.pixelToHex({ x: (data[i].x0 + 164.6719013516826) * 4, y: (328 + data[i].y0) * -4 }, layout)\n        // merge hex and data[i] into hexas[i]\n        hexas[i] = Object.assign(hex, data[i])\n        hexas[i].modified = false\n        if (hexas[i].player != null) {\n            lstTile[i] = { player: hexas[i].player, id: hexas[i].Id, cellPlayer: hexas[i].cellPlayer }\n        }\n        //renameProperty(hexas[i], \"mainCLC1\", \"activity\")\n    }\n    return [hexas, lstTile];\n}\n/* this function doesn't work */\n/* export function generateMap(data) {\n    let hexas = {};\n    let hex;\n    let hex2;\n    let rivers = [];\n    let path;\n    for (let i = 0; i < data.length; i++) {\n\n        hex = HexUtils.pixelToHex({ x: (data[i].xOutlet), y: (data[i].yOutlet) }, layout)\n        //map ardiere\n        //hex = HexUtils.pixelToHex({ x: (data[i].x0 + 164.6719013516826) * 4, y: (328 + data[i].y0) * -4 }, layout)\n        // merge hex and data[i] into hexas[i]\n        if (!hexas[i]) {\n            hexas[i] = Object.assign(hex, data[i])\n            hexas[i].modified = false\n        }\n        let j = hexas[hexas[i].downTile + 2]\n        if (!hexas[j]) {\n            hexas[j] = Object.assign(hex, data[j])\n            hexas[j].modified = false\n\n        }\n        path = {\n            start: hexas[i],\n            end: hexas[j],\n            outletFlowAcc: hexas[i].outletFlowAcc\n        }\n        rivers.push(path);\n        //renameProperty(hexas[i], \"mainCLC1\", \"activity\")\n    }\n    return [hexas, rivers]\n} */\n/* \n    Function : generateRivers \n\n    Syntax  : rivers=generateRivers()\n\n    Outputs : array of object containing the start and end of each rivers\n\n    Description : cycle through the hexagones to create and array of object path\n                    containing the hexagon where the river starts and and where it ends\n                    by reading the downStreamCell property\n    \n    Author : Hugo KELHETTER\n*/\nexport function generateRivers(moreHexas) {\n    let rivers = [];\n    let path;\n    for (let i = 0; i < Object.keys(moreHexas).length; i++) {\n        path = {\n            start: moreHexas[i],\n            end: moreHexas[moreHexas[i].downTile - 1],\n            outletFlowAcc: moreHexas[i].outletFlowAcc\n        }\n        rivers.push(path);\n    }\n    return rivers;\n\n}\n/* \n    Function : setPlayerClass\n\n    Syntax\n        playerClass=setPlayerClass(PlayerId)\n    \n    Input\n        PlayerId    :player's id\n\n    Outputs\n        playerClass :player's id on subBasin\n\n    Description\n        Compute player's id on their subBasin based on their global id\n\n    Author : Hugo KELHETTER\n*/\nexport function setPlayerClass(player) {\n    if (player === 0 || player > 9) return \"\" //attributé à aucun joueur\n    switch (player % 3) {\n        case 0: return \"troisieme\" //attribué aux joueurs 3, 6 ou 9\n        case 1: return \"premier\" //attribué aux joueurs 1, 4 ou en 7\n        case 2: return \"deuxieme\" //attribué aux joueurs 2, 5 ou 8\n        default: return \"\"\n    }\n}\n/* \n    Function : activityToString\n\n    Syntax\n        tileActivity=activityToString(activity)\n    \n    Input\n        activity    :tile's activity\n\n    Outputs\n        tileactivity:string corresponding to the activity\n\n    Description\n        returns a string based on the input\n        this is meant to set className to components and apply css style\n    \n    Author : Hugo KELHETTER\n*/\nexport function activityToString(activity) {\n    switch (activity) {\n        case 1: return \"ville\";\n        case 2: return \"agriculture\";\n        case 3: return \"foret\";\n        case 5: return \"water\"\n        default: return \"notInBassin\";\n    }\n}\n/* \n    Function : getSubBassin\n\n    Syntax\n        subBassin=getSubBassin(id)\n    \n    Input\n        id    :player's id\n\n    Outputs\n        playerClass :player's subBasin\n\n    Description\n        Calculate player's subBassin based on their id\n\n    Author : Hugo KELHETTER\n*/\nexport function getSubBassin(id) {\n    if (id < 4) return 1\n    if (id < 7) return 2\n    return 3\n}\n/* \n    Function : setMapSize\n\n    Syntax : setMapSize()\n        \n    Description : return a size considering if the scrren if in portrait or landscape \n        \n*/\n\nexport function setMapSize() {\n    return window.matchMedia('(orientation:landscape)').matches ? '50%' : '100%'\n}\n/* \n    Function : setBaseCLasses \n    \n    Syntax  : classes=setBaseClasses(hex)\n    \n    Input   : hex : object : contains the data of an hexagon\n    \n    Output : classes : string : a set of css classes to add to the hexagon\n\n    Description : return a string of classes to add to the hexagon\n        \n    Author : Hugo KELHETTER\n*/\nexport function setBaseClasses(hex) {\n    let classname = activityToString(hex.mainCLC1)\n    if (hex.eco == 1) classname += \" eco\"\n    return classname\n}"]},"metadata":{},"sourceType":"module"}